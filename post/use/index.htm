<section class="description-section">
  <h2>How to use P</h2>
  <p>
    P relies on very new technology, so it's a bit trickier to get started with than
    most libraries. You'll need 
    <a href="http://nodejs.org/">Node.js 0.10+</a> and 
    <a href="http://google.com/chrome">Chrome 26+</a> before getting started.
  </p>

  <h3>Installing and running onramp</h3>
  <p>
    onramp is a simple WebSocket server which broadcasts its connections to all other
    connections. This allows you to quickly build up a peer-to-peer network to play 
    around with.
  </p>
  <p>To install and run onramp, execute the following in your terminal:</p>
  <pre class="prettyprint">
npm install -g onramp; # install it to the PATH
onramp; # start onramp with default settings
</pre>
  <p>
    By default onramp
    starts on localhost:20500. You can change the host by passing in the 
    <code>-h [host]</code> argument; for example: <code>onramp -h ozan.io:9101</code>.
  </p>

  <h3>Downloading and using P</h3>
  <p>
    You can <a href="https://raw.github.com/oztu/p/master/dist/p.js">download the latest version of P here</a>.
    Include it in your application as you would any other script (i.e. &lt;script&gt;). P creates one global variable
    named "P".
  </p>
  <p>
    Current P only runs on Chrome with the <code>--enable-data-channels</code> flag. 
    This is because P relies on a new technology, WebRTC Data Channels, which only implemented
    in Chrome as of May 2013.
  </p>
  <p>
    The simplest way to start Chrome with the data-channels flag is from the terminal.
    For example, on my Windows box I would execute 
    <code>C:\Users\Ozan\AppData\Local\Google\Chrome\Application\chrome.exe --enable-data-channels</code>.
  </p>
<div class="api">
  <h3>API</h3>
  <ul class="unstyled well">
    <li>
      <b>P.create()</b> Create the root node
      <ul>
        <li><b>node.to(address)</b> Connect to another peer</li>
        <li><b>node.send(address)</b> Send the peer a message</li>
        <li><b>node.on(address)</b> Listen to events from the peer</li>
        <li><b>node.removeListener(address)</b> Remove event listeners from the peer</li>
        <li><b>node.close(address)</b> Close the connection to the peer</li>
      </ul>
    </li>
  </ul>

<h4 style="margin-top:20px;"><code>P.create()</code></h4>
<p>
  Creates the root node of a P application used to connect to onramp servers.
</p>
<pre class="prettyprint lang-js">
// Creates a root p instance
rootNode = P.create();

// Listens for any connections to this browser
rootNode.on('connection', function(connection){
  console.log('new connection', connection);
});

// Connects to an on ramp server
webSocketNode = rootNode.to('ws://localhost:20500');
</pre>

<h4><code>node.to(address)</code></h4>
Uses one P node to connect to another. 
<ul>
  <li>The root node can connect to WebSocket nodes (i.e. onramp servers) via their WebSocket address.</li>
  <li>WebSocket nodes can connect to WebRTC nodes with the remote connection's id as the address.</li>
  <li>WebRTC nodes can connect to other WebRTC nodes with the remote connection's id as the address.</li>
</ul>
<pre class="prettyprint lang-js">
// Use the root node to connect to the onramp server at address
webSocketNode = rootNode.to(address);

// Use the onramp node to connect to a remote WebRTC node with the 
// connection id as the address
webRtcNode = webSocketNode.to(address);

// Use a WebRTC node to connect to a remote WebRTC node with the 
// remote connection id as the address
webRtcNode = webRtcNode.to(address);
</pre>

<h4><code>node.send(arg1[, arg2, ...])</code></h4>
Send 1+ JSON-serializable arguments or 1 ArrayBuffer to the target node. The node will be able to receive the message
by listening for the 'message' or 'array buffer' events.

<pre class="prettyprint lang-js">
// anyNode.send(arg1, arg2, ...);

// Send a multi-parameter JSON message
anyNode.send('Hello', {myName: 'Alice'});

// Send an array buffer
buffer = new ArrayBuffer(12);
anyNode.send(buffer);
</pre>

<h4><code>node.on(event, callback)</code></h4>
Bind a handler for one of these events:
<ul>
  <li>
    <code>open</code>
    fires when the connection to the node is established and ready. The callback is called
    with no arguments.
  </li>
  <li>
    <code>close</code>
    fires when the connection to the node is closed. The callback is called
    with no arguments.
  </li>
  <li>
    <code>message</code>
    fires when a JSON message from the peer is received. The callback may be called with
    multiple arguments depending on the message.
  </li>
  <li>
    <code>array buffer</code>
    fires when an ArrayBuffer is received from the peer. The callback will be called with a single
    argument.
  </li>
  <li>
    <code>connection</code>
    fires when a new connection is established via this peer. The callback will be called with a single
    argument, the new node which has been connected to.
  </li>
</ul>
<pre class="prettyprint lang-js">
// Listen for connections made via this node
anyNode.on('connection', function(anotherNode){

  // Listen for messages from the new connection
  anotherNode.on('message', function(){
    console.log('arguments received', arguments);
  });
});
</pre>

<h4><code>node.removeListener(event[, callback])</code></h4>
Removes an event handler. If a specific callback which was bound isn't provided, all callbacks for the
even will be removed.
<pre class="prettyprint lang-js">
// Remove all existing message handlers.
anyNode.removeListener('message');
</pre>

<h4><code>node.close()</code></h4>
Closes a connection to a peer.
<pre class="prettyprint lang-js">
// Close the connection to the peer
anyNode.close();
</pre>
</div>
</section>